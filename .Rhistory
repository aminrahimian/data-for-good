library(tidyverse)
library(ggpubr)
install.packages("tidyverse")
install.packages("ggpubr")
library(ggpubr)
library(rstatix)
# Data preparation
# Wide format
data("selfesteem", package = "datarium")
head(selfesteem, 3)
install.packages("datarium")
# Data preparation
# Wide format
data("selfesteem", package = "datarium")
head(selfesteem, 3)
# Gather columns t1, t2 and t3 into long format
# Convert id and time into factor variables
selfesteem <- selfesteem %>%
gather(key = "time", value = "score", t1, t2, t3) %>%
convert_as_factor(id, time)
head(selfesteem, 3)
selfesteem %>%
group_by(time) %>%
get_summary_stats(score, type = "mean_sd")
bxp <- ggboxplot(selfesteem, x = "time", y = "score", add = "point")
bxp
selfesteem %>%
group_by(time) %>%
identify_outliers(score)
selfesteem %>%
group_by(time) %>%
shapiro_test(score)
ggqqplot(selfesteem, "score", facet.by = "time")
res.aov <- anova_test(data = selfesteem, dv = score, wid = id, within = time)
library(tidyverse)
library(ggpubr)
library(rstatix)
# Data preparation
# Wide format
data("selfesteem", package = "datarium")
# Data preparation
# Wide format
data("selfesteem", package = "datarium")
head(selfesteem, 3)
View(selfesteem)
# Gather columns t1, t2 and t3 into long format
# Convert id and time into factor variables
selfesteem <- selfesteem %>%
gather(key = "time", value = "score", t1, t2, t3) %>%
convert_as_factor(id, time)
# Gather columns t1, t2 and t3 into long format
# Convert id and time into factor variables
selfesteem <- selfesteem %>%
gather(key = "time", value = "score", t1, t2, t3) %>%
convert_as_factor(id, time)
head(selfesteem, 3)
View(selfesteem)
head(selfesteem, 3)
selfesteem %>%
group_by(time) %>%
get_summary_stats(score, type = "mean_sd")
aov(score~time)
aov(score~time, data = selfesteem)
summary.aov(score~time, data = selfesteem)
x-<aov(score~time, data = selfesteem)
x<-aov(score~time, data = selfesteem)
summary(x)
bxp <- ggboxplot(selfesteem, x = "time", y = "score", add = "point")
bxp
selfesteem %>%
group_by(time) %>%
identify_outliers(score)
selfesteem %>%
group_by(time) %>%
shapiro_test(score)
ggqqplot(selfesteem, "score", facet.by = "time")
bxp <- ggboxplot(selfesteem, x = "time", y = "score", add = "point")
bxp
ggqqplot(selfesteem, "score", facet.by = "time")
res.aov <- anova_test(data = selfesteem, dv = score, wid = id, within = time)
get_anova_table(res.aov)
summary(res.aov)
data("selfesteem", package = "datarium")
head(selfesteem, 3)
data("selfesteem2", package = "datarium")
head(selfesteem2, 3)
View(selfesteem2)
data("selfesteem2", package = "datarium")
head(selfesteem2, 3)
# Gather the columns t1, t2 and t3 into long format.
# Convert id and time into factor variables
selfesteem2 <- selfesteem2 %>%
gather(key = "time", value = "score", t1, t2, t3) %>%
convert_as_factor(id, time)
res.aov <- anova_test(
data = selfesteem2, dv = score, wid = id,
within = c(treatment, time)
)
get_anova_table(res.aov)
summary(aov(weight feed,data=chickwts))
summary(aov(weight~feed,data=chickwts))
read.csv("data_survey.csv")
ls
get wdp
getwd()
# from: https://www.r-bloggers.com/2020/09/simulating-paths-from-a-random-walk/
# returns the random walk path values as a vector
# (random walk always starts at 0)
# p: probability of increasing by 1
# stop if path value hits either `lower` or `upper`
run <- function(p, lower, upper) {
values <- c(0)
current <- 0
while (current > lower & current < upper) {
current <- current + ifelse(runif(1) < p, 1, -1)
values <- c(values, current)
}
values
}
N <- 100  # no. of paths to simulate
p <- 0.48
lower <- -50
upper <- 50
# simulate paths
set.seed(1055)
vlist <- replicate(N, run(p, lower, upper))
# get length of longest path
max_length <- max(sapply(vlist, length))
# make plot
par(mar = rep(0, 4))  # no margins
plot(c(1, max_length), c(lower, upper), type = "n")
for (i in 1:N) {
lines(1:length(vlist[[i]]), vlist[[i]])
}
abline(h = 0, lty = "dashed")
abline(h = lower, lwd = 2)
abline(h = upper, lwd = 2)
colorPicker <- function(values, max_length,
ls_color = c(178, 34, 34), ll_color = c(255, 204, 0),
us_color = c(0, 0, 102), ul_color = c(102, 204, 225)) {
l <- length(values)
if (values[l] < 0) {
rgb_values <- (ls_color + (ll_color - ls_color) * l / max_length) / 255
} else {
rgb_values <- (us_color + (ul_color - us_color) * l / max_length) / 255
}
rgb(rgb_values[1], rgb_values[2], rgb_values[3])
}
plot(c(1, max_length), c(lower, upper), type = "n")
for (i in 1:N) {
lines(1:length(vlist[[i]]), vlist[[i]],
col = colorPicker(vlist[[i]], max_length), lwd = 0.5)
}
abline(h = 0, lty = "dashed")
abline(h = lower, lwd = 2)
abline(h = upper, lwd = 2)
# from: https://www.r-bloggers.com/2020/09/simulating-paths-from-a-random-walk/
# returns the random walk path values as a vector
# (random walk always starts at 0)
# p: probability of increasing by 1
# stop if path value hits either `lower` or `upper`
run <- function(p, lower, upper) {
values <- c(0)
current <- 0
while (current > lower & current < upper) {
current <- current + ifelse(runif(1) < p, 1, -1)
values <- c(values, current)
}
values
}
N <- 100  # no. of paths to simulate
p <- 0.48
lower <- -50
upper <- 50
# simulate paths
set.seed(1055)
vlist <- replicate(N, run(p, lower, upper))
# get length of longest path
max_length <- max(sapply(vlist, length))
# make plot
par(mar = rep(0, 4))  # no margins
plot(c(1, max_length), c(lower, upper), type = "n")
for (i in 1:N) {
lines(1:length(vlist[[i]]), vlist[[i]])
}
abline(h = 0, lty = "dashed")
abline(h = lower, lwd = 2)
abline(h = upper, lwd = 2)
colorPicker <- function(values, max_length,
ls_color = c(178, 34, 34), ll_color = c(255, 204, 0),
us_color = c(0, 0, 102), ul_color = c(102, 204, 225)) {
l <- length(values)
if (values[l] < 0) {
rgb_values <- (ls_color + (ll_color - ls_color) * l / max_length) / 255
} else {
rgb_values <- (us_color + (ul_color - us_color) * l / max_length) / 255
}
rgb(rgb_values[1], rgb_values[2], rgb_values[3])
}
plot(c(1, max_length), c(lower, upper), type = "n")
for (i in 1:N) {
lines(1:length(vlist[[i]]), vlist[[i]],
col = colorPicker(vlist[[i]], max_length), lwd = 0.5)
}
abline(h = 0, lty = "dashed")
abline(h = lower, lwd = 2)
abline(h = upper, lwd = 2)
# from: https://www.r-bloggers.com/2020/09/simulating-paths-from-a-random-walk/
# returns the random walk path values as a vector
# (random walk always starts at 0)
# p: probability of increasing by 1
# stop if path value hits either `lower` or `upper`
run <- function(p, lower, upper) {
values <- c(0)
current <- 0
while (current > lower & current < upper) {
current <- current + ifelse(runif(1) < p, 1, -1)
values <- c(values, current)
}
values
}
N <- 10  # no. of paths to simulate
p <- 0.5
lower <- -50
upper <- 50
# simulate paths
set.seed(1055)
vlist <- replicate(N, run(p, lower, upper))
# get length of longest path
max_length <- max(sapply(vlist, length))
# make plot
par(mar = rep(0, 4))  # no margins
plot(c(1, max_length), c(lower, upper), type = "n")
for (i in 1:N) {
lines(1:length(vlist[[i]]), vlist[[i]])
}
abline(h = 0, lty = "dashed")
abline(h = lower, lwd = 2)
abline(h = upper, lwd = 2)
colorPicker <- function(values, max_length,
ls_color = c(178, 34, 34), ll_color = c(255, 204, 0),
us_color = c(0, 0, 102), ul_color = c(102, 204, 225)) {
l <- length(values)
if (values[l] < 0) {
rgb_values <- (ls_color + (ll_color - ls_color) * l / max_length) / 255
} else {
rgb_values <- (us_color + (ul_color - us_color) * l / max_length) / 255
}
rgb(rgb_values[1], rgb_values[2], rgb_values[3])
}
plot(c(1, max_length), c(lower, upper), type = "n")
for (i in 1:N) {
lines(1:length(vlist[[i]]), vlist[[i]],
col = colorPicker(vlist[[i]], max_length), lwd = 0.5)
}
abline(h = 0, lty = "dashed")
abline(h = lower, lwd = 2)
abline(h = upper, lwd = 2)
max_length
anova(m)
m <- lm(formula = ORIGINAL_INTEREST_RATE~ CREDIT_SCORE+
ORIGINAL_DEBT_TO_INCOME_RATIO+NUMBER_OF_BORROWERS,data=data)
anova(m)
data<-read.csv("loan_level_500k.csv")
setwd("~/GitHub/data-for-good")
data <- na.omit(data)
m <- lm(formula = ORIGINAL_INTEREST_RATE~ CREDIT_SCORE+
ORIGINAL_DEBT_TO_INCOME_RATIO+NUMBER_OF_BORROWERS,data=data)
data<-read.csv("loan_level_500k.csv")
setwd("~/GitHub/data-for-good")
data <- na.omit(data)
m <- lm(formula = ORIGINAL_INTEREST_RATE~ CREDIT_SCORE+
ORIGINAL_DEBT_TO_INCOME_RATIO+NUMBER_OF_BORROWERS,data=data)
anova(m)
summary(m)
View(data)
View(data)
m1 <- lm(formula = ORIGINAL_INTEREST_RATE~ CREDIT_SCORE+
ORIGINAL_DEBT_TO_INCOME_RATIO+NUMBER_OF_BORROWERS+POSTAL_CODE,data=data)
anova(m1)
summary(m1)
library(glmnet)
install.packages(glmnet)
library(glmnet)
install.packages(glmnet)
#LASSO Regression
lasso.mod <- glmnet(x[train, ], y[train], alpha=1, lambda = grid)
library(glmnet)
install.packages("glmnet", repos = "https://cran.us.r-project.org")
library(glmnet)
#LASSO Regression
lasso.mod <- glmnet(x[train, ], y[train], alpha=1, lambda = grid)
#LASSO Regression
x<- model.matrix(ORIGINAL_INTEREST_RATE ~., CREDIT_SCORE) [,-1]
y<-CREDIT_SCORE$ORIGINAL_INTEREST_RATE
#LASSO Regression
x<- model.matrix(train$ORIGINAL_INTEREST_RATE ~., train$CREDIT_SCORE) [,-1]
y<-CREDIT_SCORE$ORIGINAL_INTEREST_RATE
%>%
cols= c('ORIGINAL_INTEREST_RATE', 'CREDIT_SCORE', 'FIRST_TIME_HOMEBUYER_FLAG','ORIGINAL_DEBT_TO_INCOME_RATIO', 'NUMBER_OF_BORROWERS','POSTAL_CODE','LOAN_PURPOSE')
selected_df = loan_level_500k[cols]
selected_df = selected_df%>% drop_na()
feature_cols= c('CREDIT_SCORE', 'FIRST_TIME_HOMEBUYER_FLAG','ORIGINAL_DEBT_TO_INCOME_RATIO', 'NUMBER_OF_BORROWERS')
predictors = selected_df(feature_cols)
target_col = ('ORIGINAL_INTEREST_RATE')
target = selected_df(target_col)
loan_level_500k<-selected_df
set.seed(8)
dt = sort(sample(nrow(loan_level_500k), nrow(loan_level_500k)*.7))
train<-loan_level_500k[dt,]
test<-loan_level_500k[-dt,]
#make sure to import the CSV file
loan_level_500k <- read_csv("Desktop/School/Data For Good/loan_level_500k.csv")
set.seed(1)
knitr::opts_chunk$set(echo = TRUE)
loan_level_500k <- read.csv("loan_level_500k.csv")
cols <- c('ORIGINAL_INTEREST_RATE', 'CREDIT_SCORE', 'FIRST_TIME_HOMEBUYER_FLAG','ORIGINAL_DEBT_TO_INCOME_RATIO', 'NUMBER_OF_BORROWERS','POSTAL_CODE','LOAN_PURPOSE')
selected_df <- loan_level_500k[cols]
selected_df <- selected_df %>% drop_na()
library(readr)
library(tidyr)
cols <- c('ORIGINAL_INTEREST_RATE', 'CREDIT_SCORE', 'FIRST_TIME_HOMEBUYER_FLAG','ORIGINAL_DEBT_TO_INCOME_RATIO', 'NUMBER_OF_BORROWERS','POSTAL_CODE','LOAN_PURPOSE')
selected_df <- loan_level_500k[cols]
selected_df <- selected_df %>% drop_na()
set.seed(13)
selected_df$NOISE <- selected_df$ORIGINAL_INTEREST_RATE * rnorm(482451, 0, 1)
selected_df$NOISE2 <- selected_df$CREDIT_SCORE * rnorm(482451, 21, 5)
selected_df$NOISE3 <- selected_df$POSTAL_CODE * rnorm(482451, 7, 5)
selected_df$NOISE4 <- selected_df$ORIGINAL_INTEREST_RATE * rnorm(482451, 0, 83)
selected_df$NOISE5 <- selected_df$CREDIT_SCORE * rnorm(482451, 21, 5)
selected_df$NOISE6 <- selected_df$POSTAL_CODE * rnorm(482451, 7, 5)
selected_df$NOISE7 <- selected_df$ORIGINAL_INTEREST_RATE * rnorm(482451, -5, 1)
selected_df$NOISE8 <- selected_df$POSTAL_CODE * rnorm(482451, 71, 150)
selected_df$NOISE9 <- selected_df$ORIGINAL_INTEREST_RATE * rnorm(482451, -.000002, 1000000000)
data <- selected_df
lm.fit <- lm(ORIGINAL_INTEREST_RATE~., data = data)
lm.fit2 <- lm(ORIGINAL_INTEREST_RATE~ CREDIT_SCORE + data$FIRST_TIME_HOMEBUYER_FLAG + ORIGINAL_DEBT_TO_INCOME_RATIO + data$NUMBER_OF_BORROWERS + data$POSTAL_CODE + data$LOAN_PURPOSE  + data$NOISE + NOISE2 + NOISE3 + NOISE4 + NOISE5 + NOISE6 + NOISE7 +NOISE8, data = data)
lm.fit3 <- lm(ORIGINAL_INTEREST_RATE~ CREDIT_SCORE + data$FIRST_TIME_HOMEBUYER_FLAG + ORIGINAL_DEBT_TO_INCOME_RATIO + data$NUMBER_OF_BORROWERS + data$LOAN_PURPOSE  + data$NOISE + NOISE2 + NOISE3 + NOISE4 + NOISE5 + NOISE6 + NOISE7 +NOISE8, data = data)
lm.fit4 <- lm(ORIGINAL_INTEREST_RATE~ CREDIT_SCORE + data$FIRST_TIME_HOMEBUYER_FLAG + ORIGINAL_DEBT_TO_INCOME_RATIO + data$NUMBER_OF_BORROWERS + data$LOAN_PURPOSE  + data$NOISE + NOISE2 + NOISE3 + NOISE4 + NOISE5 + NOISE6 + NOISE7, data = data)
AIC(lm.fit)
AIC(lm.fit2)
AIC(lm.fit3)
AIC(lm.fit4)
summary(lm.fit)$R.squared
summary(lm.fit2)$R.squared
summary(lm.fit3)$R.squared
summary(lm.fit4)$R.squared
AIC(lm.fit2)
AIC(lm.fit3)
AIC(lm.fit4)
summary(lm.fit)$r.squared
summary(lm.fit2)$r.squared
summary(lm.fit3)$r.squared
summary(lm.fit4)$r.squared
AIC(lm.fit2)
AIC(lm.fit3)
AIC(lm.fit4)
